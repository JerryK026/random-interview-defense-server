tip1 : Git hub 레포에서 키보드 "." 버튼을 누르면 vscode와 같은 웹뷰로 레포를 볼 수 있습니다
또한, "?" 버튼을 누르면 키보드로 사용할 수 있는 단축어를 확인할 수 있습니다
%
tip2 : notion 공개 링크를 받았을 때, url의 프로토콜 부분을 https가 아닌 notion으로 입력하면 브라우저가 아닌 노션 앱으로 열 수 있습니다
%
tip3 : 메모리는 디스크보다 읽기 성능이 10^5 ~ 10^6배 빠릅니다
%
tip4 : java에서 배열을 복사하는 방법은 Object.clone()과 System.arraycopy 2가지 방법이 있습니다
clone()은 deep copy이나, 성능이 느립니다
arraycopy()는 shallow copy이나 성능이 빠릅니다
%
tip5 : Phantom Read란 주로 언두로그가 아닌 레코드를 읽을 때 발생합니다
레코드는 버전 컨트롤의 대상이 되지 못하기 때문에 다른 트랜잭션에서 언두 로그에 쓰기 잠금을 걸면 현재 트랜잭션은 당장 읽을 수 있는 실제 레코드에서 데이터를 읽어옵니다
이는 다른 트랜잭션에서 변경했을 가능성이 있습니다

+) InnoDB의 Repeatable Read에서 Phantom Read가 발생하지 않는 이유는 Gap Lock을 지원하기 때문입니다
Gap Lock은 읽은 레코드들 사이에 읽기 잠금을 걸기 때문에 다른 곳에서 쓰기 잠금을 걸지 못합니다
따라서 트랜잭션은 해당 레코드에 대해 같은 레코드 읽기를 보장받습니다
%
tip6 : JPA를 사용할 때는 엔티티를 직접 캐싱해선 안 됩니다
영속성 컨텍스트가 관리하는 걸 캐시가 다시 관리하면 정합성 문제가 발생하기 때문에 DTO로 변환해 캐싱해야 합니다

출처 : 실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화
%
tip7 : JPA에서 OSIV(OpenSessionInView)란, 트랜잭션 밖에서도 영속성 컨텍스트가 해당 엔티티를 관리하기 위해 DB 커넥션을 가지는 기능을 말합니다
OSIV가 켜져 있을 땐 커넥션이 마르기 쉽기 때문에 실시간 서비스에서는 해당 기능을 꺼놓고 프레젠테이션 계층으로 보내기 전 데이터를 모두 조회 후 내보내는 것이 좋습니다

출처 : 실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화
%
tip8 : SQL에서 AND로 연결된 경우에는 두 조건 중 하나라도 인덱스를 사용할 수 있으면 인덱스 스캔을 사용합니다
그러나, OR의 경우 둘 중 하나라도 인덱스를 사용하지 못하면 풀 테이블 스캔합니다
%
tip9 : CQS(Command Query Seperation) 패턴이란 모든 객체의 메서드를 쓰기 작업을 수행하는 "command"와 읽기 작업을 수행하는 "query"로 분리하는 패턴입니다
하나의 메서드는 command면서 query일 수 없으며, CQS를 지킬 시 부수효과가 일어나는 메서드를 분리할 수 있어 유지보수하기 쉬워지지만 간단한 코드도 복잡해질 수 있다는 단점을 가집니다
%
tip10 : 집계함수 / GROUP BY / DISTINCT / SELECT 절 / 사용자 변수 / UNION을 포함하는 절 등에 해당하는 서브쿼리는 가능하면 외부 쿼리로 수동 병합하는 것이 성능 향상에 도움이 됩니다

출처 : Real MySQL 8.0 1권
%
tip11 : 인덱스를 활용한 정렬은 읽는 순간에 이미 정렬돼 있기 때문에 빠른 속도로 정렬할 수 있습니다
이때  B-Tree 계열의 인덱스를 통해서만 정렬이 가능합니다
%
tip12 : MySQL에선 GROUP BY에 사용된 조건은 인덱스 처리할 수 없어, HAVING 절 튜닝을 위한 인덱스를 고려할 필요는 없습니다

출처 : Real MySQL 8.0 1권